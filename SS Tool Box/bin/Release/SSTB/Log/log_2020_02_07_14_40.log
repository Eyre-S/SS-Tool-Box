2020_02_07_14_40

[14:01:40.39] 开始加载UI
[14:01:42.00] UI加载完成，耗时：00:00:01.6080043
[14:01:42.01] 开始获取一言
[14:01:42.12] 检查更新……
[14:01:43.23] 获取一言成功，耗时：00:00:01.2392343
[14:01:48.14] 下载更新文件错误（第一更新源）：System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.WebClient.DownloadFile(Uri address, String fileName)
   在 System.Net.WebClient.DownloadFile(String address, String fileName)
   在 SS_Tool_Box_By_WPF.Main.UpdateRight() 位置 C:\Users\Stapx\OneDrive\项目\GitHub\SS-Tool-Box\SS Tool Box\Main.xaml.cs:行号 635
[14:01:48.53] 下载更新文件错误（第二更新源）：System.Net.WebException: 请求被中止: 未能创建 SSL/TLS 安全通道。
   在 System.Net.WebClient.DownloadFile(Uri address, String fileName)
   在 System.Net.WebClient.DownloadFile(String address, String fileName)
   在 SS_Tool_Box_By_WPF.Main.UpdateRight() 位置 C:\Users\Stapx\OneDrive\项目\GitHub\SS-Tool-Box\SS Tool Box\Main.xaml.cs:行号 645
[14:01:48.54] 打开更新文件错误：System.IO.FileNotFoundException: 未能找到文件“C:\Users\Stapx\OneDrive\项目\GitHub\SS-Tool-Box\SS Tool Box\bin\Release\SSTB\Update.txt”。
文件名:“C:\Users\Stapx\OneDrive\项目\GitHub\SS-Tool-Box\SS Tool Box\bin\Release\SSTB\Update.txt”
   在 System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   在 System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
   在 System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
   在 System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks, Int32 bufferSize, Boolean checkHost)
   在 System.IO.StreamReader..ctor(String path, Encoding encoding)
   在 SS_Tool_Box_By_WPF.Main.UpdateRight() 位置 C:\Users\Stapx\OneDrive\项目\GitHub\SS-Tool-Box\SS Tool Box\Main.xaml.cs:行号 656